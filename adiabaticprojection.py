#!/usr/bin/env python
# Adiabatic Projection 
# Benjamin G. Janesko 
# These routines implement the projected kinetic, exchange, and
# exchange-correlation functionals of Adiabatic Projection methods. 
# They are based on the PySCF routines 
# Calculations use the atomic orbital basis set as the projection basis set 
# 
import numpy
import re 
import scipy 
import math 
from pyscf import scf
from scipy import linalg 
from pyscf import gto
from pyscf import dft
from pyscf.gto import moleintor
from pyscf.scf import hf
from pyscf.dft import numint
from os.path import exists 
a2k = 627.5095 

def nr_gammaproj(ni, mol, grids, dmas, dmbs, Sm, relativity=0, hermi=0,
           max_memory=2000, verbose=None):
    '''Calculate the projected semilocal one particle density matrix 
    <mu|gamma_SL[rho]|nu> and derived quantities, using 3D numerical integration 

    Routine is based on the PySCF numint.py routine nr_rks 

    Args:
        ni : an instance of :class:`NumInt`

        mol : an instance of :class:`Mole`

        grids : an instance of :class:`Grids`
            grids.coords and grids.weights are needed for coordinates and weights of meshgrids.
        dmas, dmbs: 2D array or a list of 2D arrays
            Density matrix or multiple density matrices

    Kwargs:
        hermi : int
            Input density matrices symmetric or not
        max_memory : int or float
            The maximum size of cache to use (in MB).

    Returns:
        nelec is the number of electrons generated by numerical integration.
        exasum, txasum are semilocal exchange and kinetic energies 
        vmata is the matrix <mu|gammaSL[rho]|nu>
        excsum, excapsum are total and projected PBE XC energies 
        txcapsum is projected kinetic energy 
    '''
    make_rhoa, nset, nao = ni._gen_rho_evaluator(mol, dmas, hermi)
    make_rhob, nset, nao = ni._gen_rho_evaluator(mol, dmbs, hermi)

    shls_slice = (0, mol.nbas)
    ao_loc = mol.ao_loc_nr()

    nelec = numpy.zeros(nset)
    exasum = numpy.zeros(nset)
    exbsum = numpy.zeros(nset)
    excsum = numpy.zeros(nset)
    excapsum = numpy.zeros(nset)
    txasum = numpy.zeros(nset)
    txbsum = numpy.zeros(nset)
    txcapsum = numpy.zeros(nset)
    if isinstance(dmas, numpy.ndarray):
        vmata = numpy.zeros((nset,nao,nao), dtype=dmas.dtype)
        vmatb = numpy.zeros((nset,nao,nao), dtype=dmas.dtype)
    else:
        vmata = numpy.zeros((nset,nao,nao), dtype=numpy.result_type(*dmas))
        vmatb = numpy.zeros((nset,nao,nao), dtype=numpy.result_type(*dmas))
    aow = None
    ao_deriv = 1 
    for aos, mask, weight, coords \
            in ni.block_loop(mol, grids, nao, ao_deriv, max_memory):
        ao = aos[0]
        aow = numpy.ndarray(ao.shape, order='F', buffer=aow)
        Amua = numpy.ndarray(ao.shape, order='F', buffer=aow)
        Amub = numpy.ndarray(ao.shape, order='F', buffer=aow)
        nao = ao.shape[0]
        for idm in range(nset):
            rhoas = make_rhoa(idm, aos, mask, 'GGA')
            rhobs = make_rhob(idm, aos, mask, 'GGA')
            rhoa = rhoas[0]
            rhob = rhobs[0]

            # Test for zero rho 
            for i in range(nao):
              if(rhoa[i]<1e-9):
                 rhoa[i]=1e-9
              if(rhob[i]<1e-9):
                 rhob[i]=1e-9

            # Amu and the corresponding exchange & kinetic energies 
            (Amua,exa,txa) = eval_Amu_GGA(mol,coords,rhoas)
            (Amub,exb,txb) = eval_Amu_GGA(mol,coords,rhobs)

            # PBE XC energy per particle 
            exc,vxc = ni.eval_xc('PBE,PBE',(rhoas,rhobs),spin=1,relativity=relativity,deriv=1)[:2]
      
            # Projected exchange hole normalizations
            scalea = numpy.einsum('ki,ki->k',Amua,numpy.einsum('ki,ij->kj',Amua,Sm))
            scaleb = numpy.einsum('ki,ki->k',Amub,numpy.einsum('ki,ij->kj',Amub,Sm))
            scalea3 = numpy.ndarray(scalea.shape)
            scaleb3 = numpy.ndarray(scalea.shape)
            f53 = 5./3.
            for i in range(nao):
               val1 = 0
               val3 = 0
               if(rhoa[i]>1e-9):
                 n = scalea[i] / rhoa[i]
                 val1 = 1.-n
                 # Rescaled LDA kinetic energy per particle, from 'missing-plane-wave' UEG 
                 val3 = 4.5578 * rhoa[i]**(0.333) * (2-(2-n)**f53-n**f53)
               scalea[i] = (val1*val1)**0.5
               scalea3[i] = val3 
               val1 = 0
               val3 = 0
               if(rhob[i]>1e-9): 
                 n = scaleb[i] / rhob[i]
                 val1 = 1.-n
                 val3 = 4.5578 * rhob[i]**(0.333) * (2-(2-n)**f53-n**f53)
               scaleb[i] = (val1*val1)**0.5
               scaleb3[i] = val3 

            # Sum results 
            den = (rhoa+rhob) * weight
            dena = rhoa * weight
            denb = rhob * weight
            dens = (rhoa * scalea +rhob*scaleb) * weight
            nelec[idm] += den.sum()
            exasum[idm] += numpy.dot(dena, exa)
            exbsum[idm] += numpy.dot(denb, exb)
            excsum[idm] += numpy.dot(den, exc)
            excapsum[idm] += numpy.dot(dens, exc)
            txasum[idm] += numpy.dot(dena, txa)
            txbsum[idm] += numpy.dot(denb, txb)
            txcapsum[idm] += numpy.dot(scalea3*weight,rhoa)
            txcapsum[idm] += numpy.dot(scaleb3*weight,rhob)
            aow = numint._scale_ao(ao, .5*weight, out=aow)
            vmata[idm] += numpy.einsum('ki,kj->ij',Amua,aow)
            vmatb[idm] += numpy.einsum('ki,kj->ij',Amub,aow)
            rhoas = rhobs = Amua = Amub = None

    for i in range(nset):
        vmata[i] = vmata[i] + vmata[i].conj().T
        vmatb[i] = vmatb[i] + vmatb[i].conj().T
    if nset == 1:
        nelec = nelec[0]
        exasum = exasum[0]
        exbsum = exbsum[0]
        excsum = excsum[0]
        excapsum = excapsum[0]
        vmata = vmata[0]
        vmatb = vmatb[0]
        txasum = txasum[0]
        txbsum = txbsum[0]
        txcapsum = txcapsum[0]
    return nelec, exasum, txasum, vmata, exbsum, txbsum, vmatb, excsum, excapsum, txcapsum


def eval_Amu_GGA(mol,coords,rhos, shls_slice=None,
            non0tab=None, out=None, verbose=None):
    ''' Compute at each coord r 
        Amu(r) = [integral over u] gammaGGA(rho(r),nabla rho(r),r+u) AO_mu(r+u) 
        Also return exchange and kinetic energy densities corresponding to gammaGGA
    ''' 
    nat=coords.shape[0]
    rho = rhos[0]
    ex  = numpy.ndarray(rho.shape)
    tx  = numpy.ndarray(rho.shape)
    grad = rhos[1:4]
    kF = 3.89778*rho**(1./3.)
    gsq = numpy.einsum('ki,ki->i',grad,grad)
    tauW = gsq/(8*rho)
    sden = 1./(7.795*rho**(4./3.))
    ssq	= gsq*(sden**2)
    s   = ssq**(0.5)
    svec= numpy.einsum('ik,k->ik',grad,sden)
    a0 = ssq/(3.*numpy.real(scipy.special.lambertw(3.22398*ssq)))
    for i in range(nat):
      if(ssq[i]<0.00001):
        a0[i] = 0.103332
    aa = kF*kF*a0 
    Rvec= kF*svec/(2.*aa)
    R   = (numpy.einsum('ki,ki->i',Rvec,Rvec))**0.5
    for i in range(nat):
      ar=(2.*aa[i])**0.5*R[i]
      ex[i] = 0
      tx[i] = 0
      if(rho[i]>1e-9 and s[i]>1e-9 and R[i]>1e-9): 
        ex[i] = -0.253975*aa[i]**(1.5)/(R[i]*rho[i])*math.exp(-ar*ar)*math.erf(ar) # Exchange energy from gammaGGA
        tx[i] = gsq[i]/(8.*rho[i]**2.) # kinetic energy divided by rho 

    fakemol=gto.Mole()
    fakebasis={};
    for i in range(nat):
      ist = 'ghost'+str(i)
      tehdummystring = ist+' '+str((coords[i,0]+Rvec[0,i])/1.889725988)+' '+str((coords[i,1]+Rvec[1,i])/1.889725988)+' '+str((coords[i,2]+Rvec[2,i])/1.889725988)+'  '
      fakemol.atom.append(tehdummystring)
      alpha=aa[i]
      if(alpha<0.0000000001):
         alpha=0.0000000001
      fakebasis[ist] = [[0,[alpha,1.0]]]
    fakemol.basis =fakebasis;
    fakemol.build()
    # Cross-overlap
    atmc, basc, envc = gto.conc_env(mol._atm, mol._bas, mol._env,
                                fakemol._atm, fakemol._bas, fakemol._env)
    shls_slice_1e = (mol.nbas, mol.nbas+fakemol.nbas,0,mol.nbas)
    AMu = moleintor.getints('int1e_ovlp_cart',atmc,basc,envc,shls_slice_1e,1,0)
    # Add to (2*alpha/pi)^(3/4) normalization constant in amu 
    # with the (2*alpha/pi)^(3/4) exp(-a*R^2) from gammaGau
    for i in range(nat):
      alpha=aa[i]
      if(alpha<0.0000000001):
         alpha=0.0000000001
      AMu[i] = AMu[i] * (2.*alpha/math.pi)**(0.75)*math.exp(-alpha*R[i]**2.)
    return(AMu,ex,tx)


def test(geom,s,b):
    ''' 
    Test all this for given geometry and basis 
    Returns total energy, PBE XC energy, and projected exchange, XC, kinetic energies.
    '''
    mol=gto.Mole()
    mol.cart=True
    mol.build(atom=geom,spin=s,basis=b)
    return( testmol(mol) )

def testmol(mol):
    s = mol.spin
    if(s<1):
      doB = True  
      mf=scf.RHF(mol)
      mf.kernel()
      PA=mf.make_rdm1()/2. 
      PB = PA 
    else:
      mf=scf.UHF(mol)
      mf.kernel()
      doB = False 
      if(mol.nelec[1]>0): 
        doB = True
      (PA,PB)=mf.make_rdm1()
    S=mf.get_ovlp()
    T = mol.intor_symmetric('int1e_kin')

    Sm = linalg.inv(S)

    EXHFA=-0.5*numpy.einsum('ij,ji->',PA,mf.get_k(mol,PA))
    THF = numpy.einsum('ij,ji->',PA,T)
    EXHFB = 0. 
    if(doB):
      EXHFB=-0.5*numpy.einsum('ij,ji->',PB,mf.get_k(mol,PB))
      THF = THF + numpy.einsum('ij,ji->',PB,T)
    df=dft.UKS(mol)
    df.grids.level=4
    ni = df._numint
    (n,exa,txa,PLa,exb,txb,PLb,exc,excp,txcp)=nr_gammaproj(ni,mol,df.grids,PA,PB,Sm)
    PLa2=numpy.dot(Sm,numpy.dot(PLa,Sm))
    if(doB):
      PLb2=numpy.dot(Sm,numpy.dot(PLb,Sm))
    nn=numpy.einsum('ij,ji->',PLa2,S)
    if(doB):
      nn=nn+numpy.einsum('ij,ji->',PLb2,S)
    EXP =-0.5*numpy.einsum('ij,ji->',PLa2,mf.get_k(mol,PLa2))
    TXPA = numpy.einsum('ij,ji->',PLa2,T)
    TXPB = 0 
    if(doB):
      EXP =EXP-0.5*numpy.einsum('ij,ji->',PLb2,mf.get_k(mol,PLb2))
      TXPB =  numpy.einsum('ij,ji->',PLb2,T)
    print(THF)
    print(txcp) 
    return( numpy.array((mf.energy_tot(),exc,exa+exb-EXP,excp,txcp)) )

def AEtest(b):
  # Test atomization energies 
  # CH4 H2 C2H6 H2O C2H2 CH3-NH2
  CH4vals=test('''H        0.628099    0.628099    0.628099 ; C        0.000000    0.000000    0.000000 ; H       -0.628099   -0.628099    0.628099 ; H       -0.628099    0.628099   -0.628099 ; H        0.628099   -0.628099   -0.628099 ''',0,b)
  H2vals=test('''H 0.0 0.0 0.0; H 0.0 0.0 0.74''', 0,b)
  C2H6vals=test('''C        0.000000    0.000000    0.763258 ; C        0.000000    0.000000   -0.763258 ; H        0.000000    1.016928    1.157843 ; H       -0.880686   -0.508464    1.157843 ; H        0.880686   -0.508464    1.157843 ; H        0.000000   -1.016928   -1.157843 ; H       -0.880686    0.508464   -1.157843 ; H        0.880686    0.508464   -1.157843 ''', 0, b)
  H2Ovals = test('''O        0.000000    0.000000    0.117790 ; H        0.000000    0.755453   -0.471161 ; H        0.000000   -0.755453   -0.471161 ''',0,b)
  C2H2vals=test('''H        0.000000    0.000000    1.666650 ; C        0.000000    0.000000    0.603250 ; C        0.000000    0.000000   -0.603250 ; H        0.000000    0.000000   -1.666650  ''',0,b)
  CH3NH2vals=test('''C        0.051432    0.705304    0.000000 ; N        0.051432   -0.759906    0.000000 ; H       -0.942095    1.167319    0.000000 ; H        0.590310    1.061677    0.877640 ; H        0.590310    1.061677   -0.877640 ; H       -0.453572   -1.101576   -0.807607 ; H       -0.453572   -1.101576    0.807607 ''',0,b)

  Cvals=test('''C 0.0 0.0 0.0''',2,b)
  Hvals=test('''H 0.0 0.0 0.0''',1,b)
  Nvals=test('''N 0.0 0.0 0.0''',3,b)
  Ovals=test('''O 0.0 0.0 0.0''',2,b)

  print(a2k*(Cvals+4.*Hvals-CH4vals))
  print(a2k*(2.*Hvals-H2vals))
  print(a2k*(2.*Cvals+6.*Hvals-C2H6vals))
  print(a2k*(Ovals+2.*Hvals-H2Ovals))
  print(a2k*(2*Cvals+2.*Hvals-C2H2vals))
  print(a2k*(Cvals+Nvals+5.*Hvals-CH3NH2vals))
   
